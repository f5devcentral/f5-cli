image: python:3.7

stages:
    - test
    - test_functional
    - test_functional_teardown
    - docs
    - publish
    - publish_test

variables:
    FUNCTIONAL_TEST_PREFIX: 'f5clitest'
    PYTHONWARNINGS: 'ignore:Unverified HTTPS request'
    TERRAFORM_PKG_URL: 'https://releases.hashicorp.com/terraform/0.11.14/terraform_0.11.14_linux_386.zip'
    PRIMARY_DEMO_DIR: demos/primary
    # normalize env var options between ansible and terraform
    AZURE_TENANT: "$AZURE_TENANT_ID"
    AZURE_SECRET: "$AZURE_CLIENT_SECRET"
    ARM_CLIENT_ID: "$AZURE_CLIENT_ID"
    ARM_CLIENT_SECRET: "$AZURE_CLIENT_SECRET"
    ARM_SUBSCRIPTION_ID: "$AZURE_SUBSCRIPTION_ID"
    ARM_TENANT_ID: "$AZURE_TENANT_ID"

# unit tests: python 3.x (preferred)
test_unit:
    stage: test
    script:
        # install packages
        - pip3 install -r requirements.txt && pip3 install .
        # run unit tests
        - make unit_test
        # run linter
        - make lint
    tags:
        - cm-official-docker-executor

# functional tests: demo (ansible variation)
test_functional:
    stage: test_functional
    script:
        # install CLI
        - pip3 install -r requirements.txt && pip3 install .
        # install packages - ansible
        - cd ${PRIMARY_DEMO_DIR}/ansible
        - pip3 install -r requirements.txt
        # environment vars
        - export ADMIN_PWD=$(openssl rand 12 | base64)'Ul!'
        # run ansible playbook
        - ansible-playbook main.yml -e "admin_password=${ADMIN_PWD}" -e "env_prefix=${FUNCTIONAL_TEST_PREFIX}" -v
    tags:
        - cm-official-docker-executor
    only:
        variables:
            # enable this job
            - $RUN_FUNCTIONAL_TESTS == "true"

# functional tests: demo (terraform variation)
test_functional_tf:
    stage: test_functional
    script:
        # install CLI
        - pip3 install -r requirements.txt && pip3 install .
        # install packages - terraform
        - cd ${PRIMARY_DEMO_DIR}/terraform
        - curl ${TERRAFORM_PKG_URL} -o terraform.zip -vvv && unzip terraform.zip && export PATH="$PATH:$(pwd)"
        - terraform init
        # environment vars
        - export ADMIN_PWD=$(openssl rand 12 | base64)'Ul!'
        # run terraform plan
        - terraform apply -var="env_prefix=${FUNCTIONAL_TEST_PREFIX}tf" -var="admin_password=${ADMIN_PWD}" -auto-approve
    tags:
        - cm-official-docker-executor
    only:
        variables:
            # enable this job
            - $RUN_FUNCTIONAL_TESTS == "true"
    # terraform destroy command needs the state from apply
    artifacts:
        paths:
            - "${PRIMARY_DEMO_DIR}/terraform/terraform.tfstate"
        expire_in: 1 day
        when: always

# dependency security check
test_security_check:
    stage: test
    script:
        # install packages
        - pip install -r requirements.txt
        - pip install .
        # run dependency check
        - safety check -r requirements.txt
    tags:
        - cm-official-docker-executor

# functional tests: demo teardown (ansible variation)
test_functional_teardown:
    stage: test_functional_teardown
    script:
        # install CLI
        - pip3 install -r requirements.txt && pip3 install .
        # install packages - ansible
        - cd ${PRIMARY_DEMO_DIR}/ansible
        - pip3 install -r requirements.txt
        # tear down environment
        - ansible-playbook teardown.yml -e "env_prefix=${FUNCTIONAL_TEST_PREFIX}" -v
    tags:
        - cm-official-docker-executor
    when: always
    only:
        variables:
            # enable this job
            - $RUN_FUNCTIONAL_TESTS == "true"

# functional tests: demo teardown (terraform variation)
test_functional_teardown_tf:
    stage: test_functional_teardown
    script:
        # install CLI
        - pip3 install -r requirements.txt && pip3 install .
        # install packages - terraform
        - cd ${PRIMARY_DEMO_DIR}/terraform
        - curl ${TERRAFORM_PKG_URL} -o terraform.zip -vvv && unzip terraform.zip && export PATH="$PATH:$(pwd)"
        - terraform init
        # tear down environment
        - terraform destroy -var="env_prefix=${FUNCTIONAL_TEST_PREFIX}tf" -var="admin_password=value" -auto-approve
    tags:
        - cm-official-docker-executor
    when: always
    only:
        variables:
            # enable this job
            - $RUN_FUNCTIONAL_TESTS == "true"

# generate code coverage docs
docs_code_coverage:
    stage: docs
    script:
        # install packages
        - pip3 install -r requirements.txt && pip3 install .
        # generate coverage
        - make coverage
    tags:
        - cm-official-docker-executor
    artifacts:
        name: ${CI_COMMIT_REF_NAME}_code_coverage
        paths:
            - code_coverage
        expire_in: 1 month

# generate code docs
docs_code:
    stage: docs
    script:
        # install packages
        - pip install -r requirements.txt
        - pip install .
        # generate docs
        - make docs
    tags:
        - cm-official-docker-executor
    artifacts:
        name: ${CI_COMMIT_REF_NAME}_code_docs
        paths:
            - code_docs
        expire_in: 1 month

# Publish to internal artifactory
# Note: Will build and push eggs when new tags are pushed with the assumption being the package
# version has been updated. However even if it hasn't it will simply update the existing version
publish_egg_to_artifactory:
    stage: publish
    # for now publish on develop and master as well (instead of just tags)
    only:
        - tags
        - master
        - develop
    tags:
        - docker-executor
    script:
        - make build
        - EGG_FILE=$(ls dist/*.gz)
        - EGG_NAME=$(basename $EGG_FILE)
        - URL=${ARTIFACTORY_BASE_URL}/f5-cloud-solutions-pypi/f5-cli/${EGG_NAME}
        - echo ${URL}
        - >-
          UPLOAD_RESULT=$(curl -H "Authorization: Bearer ${ARTIFACTORY_TOKEN}" -X PUT --data-binary @${EGG_FILE} ${URL})
        - if [[ $? -eq 0 ]] && [[ "$UPLOAD_RESULT" == *created* ]]; then echo "Upload complete"; else echo "Upload failed"; exit 1; fi
        - echo $UPLOAD_RESULT

# publish docs to internal pages: - this job MUST be named 'pages'
pages:
    stage: publish
    environment:
        name: staging
        url: https://${CI_PROJECT_NAMESPACE}.${PAGES_DOMAIN}/${CI_PROJECT_NAME}
    tags:
        - cm-official-docker-executor
    script:
        - PUBLIC_DIR='./public'
        - mkdir -p ${PUBLIC_DIR}
        # place index.html in public dir
        - cp docs/index.html ${PUBLIC_DIR}/index.html
        # place code coverage artifacts under /coverage
        - mkdir -p ${PUBLIC_DIR}/coverage
        - cp -R code_coverage/* ${PUBLIC_DIR}/coverage
        # place code docs artifacts under /code-docs
        - mkdir -p ${PUBLIC_DIR}/code-docs
        - cp -R code_docs/html/* ${PUBLIC_DIR}/code-docs
    artifacts:
        paths:
            - public
    only:
        - develop

# publish test: test internal (artifactory) install
publish_test_internal_install:
    stage: publish_test
    script:
        # install packages - first wait until it is available after a recent publish
        - bash scripts/wait_for_resp.sh ${ARTIFACTORY_BASE_URL}/api/pypi/f5-cloud-solutions-pypi/simple/f5-cli/
        - pip3 install f5-cli --extra-index-url ${ARTIFACTORY_BASE_URL}/api/pypi/f5-cloud-solutions-pypi/simple
    tags:
        - cm-official-docker-executor
